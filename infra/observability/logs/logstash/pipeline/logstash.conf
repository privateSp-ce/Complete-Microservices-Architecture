input {
  tcp {
    mode => "server"
    port => 5044
    codec => json_lines
    host => "0.0.0.0"  # Critical: Must be 0.0.0.0
  }
}

filter {
  # Parse Spring Boot 3.x logs with trace ID and span ID
  grok {
    match => {
      "message" => "%{TIMESTAMP_ISO8601:log_timestamp}\s+%{LOGLEVEL:level}\s+\[%{DATA:service_name},%{DATA:traceId},%{DATA:spanId}\]\s+%{NUMBER:pid}\s+---\s+\[%{DATA:app_name}\]\s+\[%{DATA:thread_name}\]\s+\[%{DATA:trace_context}\]\s+%{DATA:logger_name}\s+:\s+%{GREEDYDATA:log_message}"
    }
  }

  # Use the parsed timestamp as the event timestamp
  date {
    match => [ "log_timestamp", "ISO8601" ]
    target => "@timestamp"
  }

  # Remove empty or dash-only trace IDs (for logs without tracing)
  if [traceId] == "" or [traceId] == "-" {
    mutate {
      remove_field => [ "traceId" ]
    }
  }

  if [spanId] == "" or [spanId] == "-" {
    mutate {
      remove_field => [ "spanId" ]
    }
  }
}

output {
  elasticsearch {
    hosts => ["http://elasticsearch:9200"]
    index => "%{service_name}-logs-%{+YYYY.MM.dd}"
  }
  stdout {
    codec => rubydebug
  }
}
